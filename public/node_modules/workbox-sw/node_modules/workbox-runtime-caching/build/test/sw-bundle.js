importScripts('/node_modules/mocha/mocha.js');
importScripts('/node_modules/chai/chai.js');
importScripts('/node_modules/sw-testing-helpers/build/browser/mocha-utils.js');
importScripts('/node_modules/sinon/pkg/sinon-no-sourcemaps.js');

/* globals mocha */
/* eslint-disable no-unused-vars */

self.expect = self.chai.expect;
self.chai.should();
mocha.setup({
  ui: 'bdd',
  reporter: null,
});

// This is a bit of a hack, but means workbox-runtime-caching can
// stub out fetch without triggering a mocha global leak.
// This thread inspired this "solution":
// https://github.com/sinonjs/sinon/issues/143
self.fetch = fetch;

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * A simple class to make errors and to help with testing.
 */
class ErrorFactory$1 {
  /**
   * @param {Object} errors A object containing key value pairs where the key
   * is the error name / ID and the value is the error message.
   */
  constructor(errors) {
    this._errors = errors;
  }
  /**
   * @param {string} name The error name to be generated.
   * @param {Error} [thrownError] The thrown error that resulted in this
   * message.
   * @return {Error} The generated error.
   */
  createError(name, thrownError) {
    if (!(name in this._errors)) {
      throw new Error(`Unable to generate error '${name}'.`);
    }

    let message = this._errors[name].replace(/\s+/g, ' ');
    let stack = null;
    if (thrownError) {
      message += ` [${thrownError.message}]`;
      stack = thrownError.stack;
    }

    const generatedError = new Error();
    generatedError.name = name;
    generatedError.message = message;
    generatedError.stack = stack;
    return generatedError;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

const errors = {
  'multiple-cache-will-update-plugins': 'You cannot register more than one ' +
    'plugin that implements cacheWillUpdate.',
  'multiple-cached-response-will-be-used-plugins': 'You cannot register more ' +
    'than one plugin that implements cachedResponseWillBeUsed.',
  'invalid-response-for-caching': 'The fetched response could not be cached ' +
    'due to an invalid response code.',
  'no-response-received': 'No response received; falling back to cache.',
  'bad-cache-id': `The 'cacheId' parameter must be a string with at least ` +
    `one character.`,
};

var ErrorFactory = new ErrorFactory$1(errors);

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var stackframe = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (typeof undefined === 'function' && undefined.amd) {
        undefined('stackframe', [], factory);
    } else {
        module.exports = factory();
    }
}(commonjsGlobal, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str[0].toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps);

    function StackFrame(obj) {
        if (obj instanceof Object) {
            for (var i = 0; i < props.length; i++) {
                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                    this['set' + _capitalize(props[i])](obj[props[i]]);
                }
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));
});

var errorStackParser = createCommonjsModule(function (module, exports) {
(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (typeof undefined === 'function' && undefined.amd) {
        undefined('error-stack-parser', ['stackframe'], factory);
    } else {
        module.exports = factory(stackframe);
    }
}(commonjsGlobal, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var tokens = line.split('@');
                    var locationParts = this.extractLocation(tokens.pop());
                    var functionName = tokens.join('@') || undefined;

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-disable require-jsdoc */

function atLeastOne(object) {
  const parameters = Object.keys(object);
  if (!parameters.some((parameter) => object[parameter] !== undefined)) {
    throwError('Please set at least one of the following parameters: ' +
      parameters.map((p) => `'${p}'`).join(', '));
  }
}



function isInstance(object, expectedClass) {
  const parameter = Object.keys(object).pop();
  if (!(object[parameter] instanceof expectedClass)) {
    throwError(`The '${parameter}' parameter must be an instance of
      '${expectedClass.name}'`);
  }
}



function isType(object, expectedType) {
  const parameter = Object.keys(object).pop();
  const actualType = typeof object[parameter];
  if (actualType !== expectedType) {
    throwError(`The '${parameter}' parameter has the wrong type. (Expected:
      ${expectedType}, actual: ${actualType})`);
  }
}

function isArrayOfType(object, expectedType) {
  const parameter = Object.keys(object).pop();
  const message = `The '${parameter}' parameter should be an array containing
    one or more '${expectedType}' elements.`;

  if (!Array.isArray(object[parameter])) {
    throwError(message);
  }

  for (let item of object[parameter]) {
    if (typeof item !== expectedType) {
      throwError(message);
    }
  }
}





function throwError(message) {
  // Collapse any newlines or whitespace into a single space.
  message = message.replace(/\s+/g, ' ');

  const error = new Error(message);
  error.name = 'assertion-failed';

  const stackFrames = errorStackParser.parse(error);

  // If, for some reason, we don't have all the stack information we need,
  // we'll just end up throwing a basic Error.
  if (stackFrames.length >= 3) {
    // Assuming we have the stack frames, set the message to include info
    // about what the underlying method was, and set the name to reflect
    // the assertion type that failed.
    error.message = `Invalid call to ${stackFrames[2].functionName}() â€” ` +
      message;
  }

  throw error;
}

/* eslint-disable no-console */

/**
 * A simple helper to manage the print of a set of logs
 */
class LogGroup {
  /**
   * @param {object} input
   */
  constructor() {
    this._logs = [];
    this._childGroups = [];

    this._isFallbackMode = false;
    const ffRegex = /Firefox\/(\d*)\.\d*/.exec(navigator.userAgent);
    if (ffRegex) {
      try {
        const ffVersion = parseInt(ffRegex[1], 10);
        if (ffVersion < 55) {
          this._isFallbackMode = true;
        }
      } catch (err) {
        this._isFallbackMode = true;
      }
    }

    if (/Edge\/\d*\.\d*/.exec(navigator.userAgent)) {
      this._isFallbackMode = true;
    }
  }

  /**
   *@param {object} logDetails
   */
  addPrimaryLog(logDetails) {
    this._primaryLog = logDetails;
  }

  /**
   *@param {object} logDetails
   */
  addLog(logDetails) {
    this._logs.push(logDetails);
  }

  /**
   * @param {object} group
   */
  addChildGroup(group) {
    if (group._logs.length === 0) {
      return;
    }

    this._childGroups.push(group);
  }

  /**
   * prints out this log group to the console.
   */
  print() {
    if (this._logs.length === 0 && this._childGroups.length === 0) {
      this._printLogDetails(this._primaryLog);
      return;
    }

    if (this._primaryLog) {
      if (!this._isFallbackMode) {
        console.groupCollapsed(...this._getLogContent(this._primaryLog));
      } else {
        this._printLogDetails(this._primaryLog);
      }
    }

    this._logs.forEach((logDetails) => {
      this._printLogDetails(logDetails);
    });

    this._childGroups.forEach((group) => {
      group.print();
    });

    if (this._primaryLog && !this._isFallbackMode) {
      console.groupEnd();
    }
  }

  /**
   * Prints the specific logDetails object.
   * @param {object} logDetails
   */
  _printLogDetails(logDetails) {
    const logFunc = logDetails.logFunc ? logDetails.logFunc : console.log;
    logFunc(...this._getLogContent(logDetails));
  }

  /**
   * Returns a flattened array of message with colors and args.
   * @param {object} logDetails
   * @return {Array} Returns an array of arguments to pass to a console
   * function.
   */
  _getLogContent(logDetails) {
    let message = logDetails.message;
    if (this._isFallbackMode && typeof message === 'string') {
      // Replace the %c value with an empty string.
      message = message.replace(/%c/g, '');
    }

    let allArguments = [message];

    if (!this._isFallbackMode && logDetails.colors) {
      allArguments = allArguments.concat(logDetails.colors);
    }

    if (logDetails.args) {
      allArguments = allArguments.concat(logDetails.args);
    }
    return allArguments;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * @private
 * @return {boolean} True, if we're running in the service worker global scope.
 * False otherwise.
 */


/**
 * @private
 * @return {boolean} True, if we're running a development bundle.
 * False otherwise.
 */
function isDevBuild() {
  // `BUILD_PROCESS_REPLACE::BUILD_TARGET` is replaced during the build process.
  return `BUILD_PROCESS_REPLACE::BUILD_TARGET` === `dev`;
}

/**
 * @private
 * @return {boolean} True, if we're running on localhost or the equivalent IP
 * address. False otherwise.
 */

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-disable no-console */

self.workbox = self.workbox || {};
self.workbox.LOG_LEVEL = self.workbox.LOG_LEVEL || {
  none: -1,
  verbose: 0,
  debug: 1,
  warn: 2,
  error: 3,
};

const LIGHT_GREY = `#bdc3c7`;
const DARK_GREY = `#7f8c8d`;
const LIGHT_GREEN = `#2ecc71`;
const LIGHT_YELLOW = `#f1c40f`;
const LIGHT_RED = `#e74c3c`;
const LIGHT_BLUE = `#3498db`;

/**
 * A class that will only log given the current log level
 * defined by the developer.
 *
 * Define custom log level by setting `self.workbox.logLevel`.
 *
 * @example
 *
 * self.workbox.logLevel = self.workbox.LOG_LEVEL.verbose;
 *
 * @private
 */
class LogHelper {
  /**
   * LogHelper constructor.
   */
  constructor() {
    this._defaultLogLevel = isDevBuild() ?
      self.workbox.LOG_LEVEL.debug :
      self.workbox.LOG_LEVEL.warn;
  }

  /**
   * The most verbose log level.
   *
   * @param {Object} options The options of the log.
   */
  log(options) {
    this._printMessage(self.workbox.LOG_LEVEL.verbose, options);
  }

  /**
   * Useful for logs that are more exceptional that log()
   * but not severe.
   *
   * @param {Object} options The options of the log.
   */
  debug(options) {
    this._printMessage(self.workbox.LOG_LEVEL.debug, options);
  }

  /**
   * Warning messages.
   *
   * @param {Object} options The options of the log.
   */
  warn(options) {
    this._printMessage(self.workbox.LOG_LEVEL.warn, options);
  }

  /**
   * Error logs.
   *
   * @param {Object} options The options of the log.
   */
  error(options) {
    this._printMessage(self.workbox.LOG_LEVEL.error, options);
  }

  /**
   * Method to print to the console.
   * @param {number} logLevel
   * @param {Object} logOptions
   */
  _printMessage(logLevel, logOptions) {
    if (!this._shouldLogMessage(logLevel, logOptions)) {
      return;
    }

    const logGroups = this._getAllLogGroups(logLevel, logOptions);
    logGroups.print();
  }

  /**
   * Print a user friendly log to the console.
   * @param  {numer} logLevel A number from self.workbox.LOG_LEVEL
   * @param  {Object} logOptions Arguments to print to the console
   * @return {LogGroup} Returns a log group to print to the console.
   */
  _getAllLogGroups(logLevel, logOptions) {
    const topLogGroup = new LogGroup();

    const primaryMessage = this._getPrimaryMessageDetails(logLevel, logOptions);
    topLogGroup.addPrimaryLog(primaryMessage);

    if (logOptions.error) {
      const errorMessage = {
        message: logOptions.error,
        logFunc: console.error,
      };
      topLogGroup.addLog(errorMessage);
    }

    const extraInfoGroup = new LogGroup();
    if (logOptions.that && logOptions.that.constructor &&
      logOptions.that.constructor.name) {
      const className = logOptions.that.constructor.name;
      extraInfoGroup.addLog(
        this._getKeyValueDetails('class', className)
      );
    }

    if (logOptions.data) {
      if (typeof logOptions.data === 'object' &&
        !(logOptions.data instanceof Array)) {
        Object.keys(logOptions.data).forEach((keyName) => {
          extraInfoGroup.addLog(
            this._getKeyValueDetails(keyName, logOptions.data[keyName])
          );
        });
      } else {
        extraInfoGroup.addLog(
          this._getKeyValueDetails('additionalData', logOptions.data)
        );
      }
    }

    topLogGroup.addChildGroup(extraInfoGroup);

    return topLogGroup;
  }

  /**
   * This is a helper function to wrap key value pairss to a colored key
   * value string.
   * @param  {string} key
   * @param  {string} value
   * @return {Object} The object containing a message, color and Arguments
   * for the console.
   */
  _getKeyValueDetails(key, value) {
    return {
      message: `%c${key}: `,
      colors: [`color: ${LIGHT_BLUE}`],
      args: value,
    };
  }

  /**
   * Helper method to color the primary message for the log
   * @param  {number} logLevel   One of self.workbox.LOG_LEVEL
   * @param  {Object} logOptions Arguments to print to the console
   * @return {Object} Object containing the message and color info to print.
   */
  _getPrimaryMessageDetails(logLevel, logOptions) {
    let logLevelName;
    let logLevelColor;
    switch (logLevel) {
      case self.workbox.LOG_LEVEL.verbose:
        logLevelName = 'Info';
        logLevelColor = LIGHT_GREY;
        break;
      case self.workbox.LOG_LEVEL.debug:
        logLevelName = 'Debug';
        logLevelColor = LIGHT_GREEN;
        break;
      case self.workbox.LOG_LEVEL.warn:
        logLevelName = 'Warn';
        logLevelColor = LIGHT_YELLOW;
        break;
      case self.workbox.LOG_LEVEL.error:
        logLevelName = 'Error';
        logLevelColor = LIGHT_RED;
        break;
    }

    let primaryLogMessage = `%cðŸ”§ %c[${logLevelName}]`;
    const primaryLogColors = [
      `color: ${LIGHT_GREY}`,
      `color: ${logLevelColor}`,
    ];

    let message;
    if (typeof logOptions === 'string') {
      message = logOptions;
    } else if (logOptions.message) {
      message = logOptions.message;
    }

    if (message) {
      message = message.replace(/\s+/g, ' ');
      primaryLogMessage += `%c ${message}`;
      primaryLogColors.push(`color: ${DARK_GREY}; font-weight: normal`);
    }

    return {
      message: primaryLogMessage,
      colors: primaryLogColors,
    };
  }

  /**
   * Test if the message should actually be logged.
   * @param {number} logLevel The level of the current log to be printed.
   * @param {Object|String} logOptions The options to log.
   * @return {boolean} Returns true of the message should be printed.
   */
  _shouldLogMessage(logLevel, logOptions) {
    if (!logOptions) {
      return false;
    }

    let minValidLogLevel = this._defaultLogLevel;
    if (self && self.workbox && typeof self.workbox.logLevel === 'number') {
      minValidLogLevel = self.workbox.logLevel;
    }

    if (minValidLogLevel === self.workbox.LOG_LEVEL.none ||
      logLevel < minValidLogLevel) {
      return false;
    }

    return true;
  }
}

var logHelper = new LogHelper();

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Use this plugin to cache responses with certain HTTP status codes or
 * header values.
 *
 * Defining both status codes and headers will cache requests with a matching
 * status code and a matching header.
 *
 * @example
 * new workbox.cacheableResponse.CacheableResponse({
 *   statuses: [0, 200, 404],
 *   headers: {
 *     'Example-Header-1': 'Header-Value-1'
 *     'Example-Header-2': 'Header-Value-2'
 *   }
 * })
 *
 * @memberof module:workbox-cacheable-response
 */
class CacheableResponse {
  /**
   * Creates a new `Plugin` instance, which stores configuration and logic
   * to determine whether a `Response` object is cacheable or not.
   *
   * If multiple criteria are present (e.g. both `statuses` and `headers`), then
   * the `Response` needs to meet all of the criteria to be cacheable.
   *
   * @param {Object} input
   * @param {Array<Number>} [input.statuses] The status codes that are
   *        checked when determining whether a `Response` is cacheable.
   * @param {Object<String,String>} [input.headers] The header values that are
   *        checked when determining whether a `Response` is cacheable.
   */
  constructor({statuses, headers} = {}) {
    atLeastOne({statuses, headers});
    if (statuses !== undefined) {
      isArrayOfType({statuses}, 'number');
    }
    if (headers !== undefined) {
      isType({headers}, 'object');
    }

    this.statuses = statuses;
    this.headers = headers;
  }

  /**
   * Checks a response to see whether it's cacheable or not, based on the
   * configuration of this object.
   *
   * @param {Object} input
   * @param {Response} input.response The response that might be cached.
   * @param {Request} [input.request] Optionally, the request that led to the
   *        response.
   * @return {boolean} `true` if the `Response` is cacheable, based on the
   *          configuration of this object, and `false` otherwise.
   */
  isResponseCacheable({request, response} = {}) {
    isInstance({response}, Response);

    let cacheable = true;

    if (this.statuses) {
      cacheable = this.statuses.includes(response.status);
    }

    if (this.headers && cacheable) {
      cacheable = Object.keys(this.headers).some((headerName) => {
        return response.headers.get(headerName) === this.headers[headerName];
      });
    }

    if (!cacheable) {
      const data = {response};
      if (this.statuses) {
        data['valid-status-codes'] = JSON.stringify(this.statuses);
      }
      if (this.headers) {
        data['valid-headers'] = JSON.stringify(this.headers);
      }
      if (request) {
        data['request'] = request;
      }

      logHelper.debug({
        message: `The response does not meet the criteria for being added to the
          cache.`,
        data,
      });
    }

    return cacheable;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Use this plugin to cache responses with certain HTTP status codes or
 * header values.
 *
 * Defining both status codes and headers will cache requests with a matching
 * status code and a matching header.
 *
 * This class is meant to be automatically invoked as a plugin to a
 * {@link module:workbox-runtime-caching.RequestWrapper|RequestWrapper}, which
 * is used by the `workbox-sw` and `workbox-runtime-caching` modules.
 *
 * If you would like to use this functionality outside of the `RequestWrapper`
 * context, please use the `CacheableResponse` class directly.
 *
 * @example
 * new workbox.cacheableResponse.CacheableResponsePlugin({
 *   statuses: [0, 200, 404],
 *   headers: {
 *     'Example-Header-1': 'Header-Value-1'
 *     'Example-Header-2': 'Header-Value-2'
 *   }
 * });
 *
 * @memberof module:workbox-cacheable-response
 */
class CacheableResponsePlugin extends CacheableResponse {
  /**
   * A "lifecycle" callback that will be triggered automatically by the
   * `workbox.runtimeCaching` handlers prior to an entry being added to a cache.
   *
   * @private
   * @param {Object} input
   * @param {Request} input.request The request that led to the response.
   * @param {Response} input.response The response that might be cached.
   * @return {boolean} `true` if the `Response` is cacheable, based on the
   *          configuration of this object, and `false` otherwise.
   */
  cacheWillUpdate({request, response} = {}) {
    return this.isResponseCacheable({request, response});
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * # workbox-cacheable-response
 *
 * Given a `Response` object this library determines whether
 * it's "cacheable", based on the response's status code and / or
 * header values.
 *
 * Most develpers will use this module by instantiating a new
 * `CachaebleResponsePlugin` and passing it to a
 * {@link module:workbox-runtime-caching.RequestWrapper|RequestWrapper},
 * as shown in the example below.
 *
 * @example <caption>Using the CachaebleResponsePlugin class in a
 * service worker.</caption>
 *
 * // The responses will be cached if the response code is 0, 200, or 404, and
 * // will not be cached otherwise.
 * const cacheablePlugin = new workbox.cacheableResponse.Plugin({
 *   statuses: [0, 200, 404]
 * });
 *
 * const requestWrapper = new workbox.runtimeCaching.RequestWrapper({
 *   cacheName: 'runtime-cache',
 *   plugins: [
 *     cacheablePlugin
 *   ]
 * });
 *
 * const route = new workbox.routing.RegExpRoute({
 *   match: ({url}) => url.domain === 'example.com',
 *   handler: new workbox.runtimeCaching.StaleWhileRevalidate({requestWrapper})
 * });
 *
 * @module workbox-cacheable-response
 */

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * The default cache name, used by
 * {@link module:workbox-runtime-caching.RequestWrapper|RequestWrapper} when
 * there's no name provided.
 *
 * It combines a constant prefix with the service worker `scope`, ensuring
 * that multiple service workers used on the same origin will have
 * different default caches.
 *
 * Calling this method without any parameters will return
 * `workbox-runtime-caching-<service worker scope>`.
 *
 * If you pass in a cacheId, it will be prepended, returning:
 * `<cacheid>-workbox-runtime-caching-<service worker scope>`.
 *
 * @param {Object} input
 * @param {string} [input.cacheId] This will be prepended to the default cache
 * name.
 * @return {string} Returns the default cache name used based on optional
 * inputs.
 *
 * @memberof module:workbox-runtime-caching
 */
const getDefaultCacheName = ({cacheId} = {}) => {
  let cacheName = `workbox-runtime-caching`;
  if (cacheId) {
    cacheName = `${cacheId}-${cacheName}`;
  }

  if (self && self.registration) {
   cacheName += `-${self.registration.scope}`;
  }

  return cacheName;
};

/**
 * A list of the callback method names that the RequestWrapper might trigger.
 *
 * @private
 * @type {Array.<string>}
 * @memberof module:workbox-runtime-caching
 */
const pluginCallbacks = [
  'cacheDidUpdate',
  'cachedResponseWillBeUsed',
  'cacheWillUpdate',
  'fetchDidFail',
  'requestWillFetch',
];

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Helper method to "clean" a redirected response, so that it could be used
 * to fulfill a navigation request.
 * See https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
 *
 * @private
 * @param {Object} input
 * @param {Response} input.response The original response. The body will not
 * be consumed.
 * @return {Promise<Response>} A clone of the response, with `redirected` false.
 */
var cleanResponseCopy = ({response}) => {
  isInstance({response}, Response);

  const clonedResponse = response.clone();

  // Not all browsers support the Response.body stream, so fall back to reading
  // the entire body into memory as a blob.
  const bodyPromise = 'body' in clonedResponse ?
    Promise.resolve(clonedResponse.body) :
    clonedResponse.blob();

  return bodyPromise.then((body) => {
    // new Response() is happy when passed either a stream or a Blob.
    return new Response(body, {
      headers: clonedResponse.headers,
      status: clonedResponse.status,
      statusText: clonedResponse.statusText,
    });
  });
};

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * Called prior to a response being written to the cache. This allows you to
 * prevent the cache from being updated if the response doesn't meet your
 * custom criteria.
 *
 * @example <caption>Determines whether a response is cacheable based on
 * whether its Cache-Control header contains the string 'no-cache'.</caption>
 *
 * async function cacheWillUpdate({response}) {
 *   return !response.headers.get('cache-control').includes('no-cache');
 * }
 *
 * @callback cacheWillUpdate
 * @param {Object} input
 * @param {Request} input.request The original request.
 * @param {Response} input.response The response to the request, based on the
 * configured strategy.
 * @return {Promise<Boolean>} `true` if the response meets your criteria for
 * being added to the appropriate cache, and `false` if it doesn't.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * Called after a response has been written to the cache.
 *
 * @example <caption>Logs a message when the cache has been updated.</caption>
 *
 * async function cacheDidUpdate({cacheName, url}) {
 *   console.log(`The entry for ${url} in cache ${cacheName} was updated.`);
 * }
 *
 * @callback cacheDidUpdate
 * @param {Object} input
 * @param {String} input.cacheName The name of the cache that was updated.
 * @param {String} input.url The URL used as a key for the cache.
 * @param {Response|null} input.oldResponse The response that was previously in
 * the cache, prior to the update, or `null` if the cache didn't previously
 * contain an entry for `url`.
 * @param {Response|null} input.newResponse The response that was written to
 * the cache.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * Called before a previously cached response that has been read from the cache
 * is used. This allows you to modify it or return `null` if it's not valid.
 *
 * @example <caption>Returns `null` to indicate that a cached response shouldn't
 * be used if its Date header is too far in the past.</caption>
 *
 * async function cachedResponseWillBeUsed({cachedResponse}) {
 *   if (cachedResponse) {
 *     const dateHeader = cachedResponse.headers.get('date');
 *     const date = new Date(dateHeader);
 *     if (dateHeader && (Date.now() - date.getTime()) < 1000) {
 *       return cachedResponse;
 *     }
 *   }
 *
 *   return null;
 * }
 *
 * @callback cachedResponseWillBeUsed
 * @param {Object} input
 * @param {Request} input.request The original request.
 * @param {Cache} input.cache An open instance of the cache.
 * @param {String} input.cacheName The name corresponding to `cache`.
 * @param {Response|null} input.cachedResponse The response for `request` that's
 * currently in `cache`, or `null` if there isn't currently a response cached.
 * @param {Object} input.matchOptions The
 * [cache match options](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match#Parameters)
 * that were configured when the current `RequestWrapper` was constructed.
 * @return {Promise<Response|null>} The response to be used as the effective
 * cache match. This might be the same response as `cachedResponse`, if it was
 * valid, a modified version of the response, or `null` if there's no valid
 * match.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * Called prior to a network request being made. This allows you to update the
 * request's URL or headers as appropriate, or just return the original request
 * if there are no modifications needed.
 *
 * @example <caption>Appends a URL parameter to all outgoing requests.</caption>
 *
 * async function requestWillFetch({request}) {
 *   const url = new URL(request.url);
 *   url.searchParams.set('from-workbox', 'true');
 *   return new Request(url.href, {headers: request.headers});
 * }
 *
 * @callback requestWillFetch
 * @param {Object} input
 * @param {Request} input.request The request that would otherwise have been
 * made against the network.
 * @return {Promise<Request>} The request that will be used against the network
 * instead.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * Called after a network request has failed. This allows you to report the
 * failure, or save a copy of the failed request to be retried later.
 *
 * @example <caption>Logs a message when a network request fails.</caption>
 *
 * async function fetchDidFail({request}) {
 *   const body = await request.text();
 *   console.log(`A request for ${request.url} with body ${body} failed.`);
 * }
 *
 * @callback fetchDidFail
 * @param {Object} input
 * @param {Request} input.request A clone of the request that failed. You can
 * consume the request's body if needed.
 *
 * @memberof module:workbox-runtime-caching.RequestWrapper
 */

/**
 * This class is used by the various subclasses of
 * [Handler]{@link module:workbox-runtime-caching.Handler} to configure the
 * cache name and any desired plugins, which is to say classes that implement
 * request lifecycle callbacks.
 *
 * It automatically triggers any registered callbacks at the appropriate time.
 *
 * @memberof module:workbox-runtime-caching
 */
class RequestWrapper {
  /**
   * Constructor for RequestWrapper.
   * @param {Object} input
   * @param {string} [input.cacheName] The name of the cache to use for Handlers
   *        that involve caching. If none is provided, a default name that
   *        includes the current service worker scope will be used.
   * @param {Array.<Object>} [input.plugins] Any plugins that should be
   *        invoked.
   * @param {Object} [input.fetchOptions] Values passed along to the
   *        [`init`](https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch#Parameters)
   *        of all `fetch()` requests made by this wrapper.
   * @param {Object} [input.matchOptions] Values passed along to the
   *        [`options`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match#Parameters)
   *        of all cache `match()` requests made by this wrapper.
   */
  constructor({cacheName, cacheId, plugins, fetchOptions, matchOptions} = {}) {
    if (cacheId && (typeof cacheId !== 'string' || cacheId.length === 0)) {
      throw ErrorFactory.createError('bad-cache-id');
    }

    if (cacheName) {
      isType({cacheName}, 'string');
      this.cacheName = cacheName;
      if (cacheId) {
        this.cacheName = `${cacheId}-${this.cacheName}`;
      }
    } else {
      this.cacheName = getDefaultCacheName({cacheId});
    }

    if (fetchOptions) {
      isType({fetchOptions}, 'object');
      this.fetchOptions = fetchOptions;
    }

    if (matchOptions) {
      isType({matchOptions}, 'object');
      this.matchOptions = matchOptions;
    }

    this.plugins = new Map();

    if (plugins) {
      isArrayOfType({plugins}, 'object');

      plugins.forEach((plugin) => {
        for (let callbackName of pluginCallbacks) {
          if (typeof plugin[callbackName] === 'function') {
            if (!this.plugins.has(callbackName)) {
              this.plugins.set(callbackName, []);
            } else if (callbackName === 'cacheWillUpdate') {
              throw ErrorFactory.createError(
                'multiple-cache-will-update-plugins');
            } else if (callbackName === 'cachedResponseWillBeUsed') {
              throw ErrorFactory.createError(
                'multiple-cached-response-will-be-used-plugins');
            }
            this.plugins.get(callbackName).push(plugin);
          }
        }
      });
    }

    if (this.plugins.has('cacheWillUpdate')) {
      this._userSpecifiedCachableResponsePlugin =
        this.plugins.get('cacheWillUpdate')[0];
    }
  }


  /**
   * @private
   * @return {function} The default plugin used to determine whether a
   *         response is cacheable.
   */
  getDefaultCacheableResponsePlugin() {
    // Lazy-construct the CacheableResponsePlugin instance.
    if (!this._defaultCacheableResponsePlugin) {
      this._defaultCacheableResponsePlugin =
        new CacheableResponsePlugin({statuses: [200]});
    }
    return this._defaultCacheableResponsePlugin;
  }

  /**
   * Opens a cache and maintains a reference to that cache
   * for future use.
   *
   * @example
   * requestWrapper.getCache()
   * .then((openCache) => {
   *    ...
   * });
   *
   * @return {Promise<Cache>} An open `Cache` instance based on the configured
   * `cacheName`.
   */
  async getCache() {
    if (!this._cache) {
      this._cache = await caches.open(this.cacheName);
    }
    return this._cache;
  }

  /**
   * Wraps `cache.match()`, using the previously configured cache name and match
   * options.
   *
   * @example
   * requestWrapper.match({event.request})
   * .then((response) => {
   *   if (!response) {
   *     // No response in cache.
   *     return;
   *   }
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request|string} input.request The key for the cache lookup.
   * @return {Promise.<Response>} The cached response.
   */
  async match({request}) {
    atLeastOne({request});

    const cache = await this.getCache();
    let cachedResponse = await cache.match(request, this.matchOptions);

    if (this.plugins.has('cachedResponseWillBeUsed')) {
      const plugin = this.plugins.get('cachedResponseWillBeUsed')[0];
      cachedResponse = await plugin.cachedResponseWillBeUsed({
        request, cache, cachedResponse,
        matchOptions: this.matchOptions, cacheName: this.cacheName,
      });
    }

    return cachedResponse;
  }

  /**
   * Wraps `fetch()`, calls all `requestWillFetch` before making the network
   * request, and calls any `fetchDidFail` callbacks from the
   * registered plugins if the request fails.
   *
   * @example
   * requestWrapper.fetch({
   *   request: event.request
   * })
   * .then((response) => {
   *  ...
   * })
   * .catch((err) => {
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request|string} input.request The request or URL to be fetched.
   * @return {Promise.<Response>} The network response.
   */
  async fetch({request}) {
    if (typeof request === 'string') {
      request = new Request(request);
    } else {
      isInstance({request}, Request);
    }

    // If there is a fetchDidFail plugin, we need to save a clone of the
    // original request before it's either modified by a requestWillFetch
    // plugin or before the original request's body is consumed via fetch().
    const clonedRequest = this.plugins.has('fetchDidFail') ?
      request.clone() : null;

    if (this.plugins.has('requestWillFetch')) {
      for (let plugin of this.plugins.get('requestWillFetch')) {
        const returnedRequest = await plugin.requestWillFetch({request});
        isInstance({returnedRequest}, Request);
        request = returnedRequest;
      }
    }

    try {
      return await fetch(request, this.fetchOptions);
    } catch (err) {
      if (this.plugins.has('fetchDidFail')) {
        for (let plugin of this.plugins.get('fetchDidFail')) {
          await plugin.fetchDidFail({request: clonedRequest.clone()});
        }
      }

      throw err;
    }
  }

  /**
   * Combines both fetching and caching using the previously configured options
   * and calling the appropriate plugins.
   *
   * By default, responses with a status of [2xx](https://fetch.spec.whatwg.org/#ok-status)
   * will be considered valid and cacheable, but this could be overridden by
   * configuring one or more plugins that implement the `cacheWillUpdate`
   * lifecycle callback.
   *
   * @example
   * requestWrapper.fetchAndCache({
   *   request: event.request
   * })
   * .then((response) => {
   *  ...
   * })
   * .catch((err) => {
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request} input.request The request to fetch.
   * @param {boolean} [input.waitOnCache] `true` means the method should wait
   *        for the cache.put() to complete before returning. The default value
   *        of `false` means return without waiting. It this value is true
   *        and the response can't be cached, an error will be thrown.
   * @param {Request} [input.cacheKey] Supply a cacheKey if you wish to cache
   *        the response against an alternative request to the `request`
   *        argument.
   * @param {function} [input.cacheResponsePlugin] Allows the
   *        caller to override the default check for cacheability, for
   *        situations in which the cacheability check wasn't explicitly
   *        configured when constructing the `RequestWrapper`.
   * @param {boolean} [input.cleanRedirects] If true, a "clean" copy of any
   * redirected responses will be added to the cache, since redirected responses
   * [can't be used](https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1)
   * to satisfy navigation requests. Defaults to false.
   * @return {Promise.<Response>} The network response.
   */
  async fetchAndCache(
    {request, waitOnCache, cacheKey, cacheResponsePlugin, cleanRedirects}) {
    atLeastOne({request});

    let cachingComplete;
    const response = await this.fetch({request});

    // We need flexibility in determining whether a given response should
    // be added to the cache. There are several possible ways that this logic
    // might be specified, and they're given the following precedence:
    // 1. Passing in a `CacheableResponsePlugin` to the `RequestWrapper`
    //    constructor, which sets this._userSpecifiedCachableResponsePlugin.
    // 2. Passing in a parameter to the fetchAndCache() method (done by certain
    //    runtime handlers, like `StaleWhileRevalidate`), which sets
    //    cacheResponsePlugin.
    // 3. The default that applies to anything using the `RequestWrapper` class
    //    that doesn't specify the custom behavior, which is accessed via
    //    the this.getDefaultCacheableResponsePlugin().
    const effectiveCacheableResponsePlugin =
      this._userSpecifiedCachableResponsePlugin ||
      cacheResponsePlugin ||
      this.getDefaultCacheableResponsePlugin();

    // Whichever plugin we've decided is appropriate, we now call its
    // cacheWillUpdate() method to determine cacheability of the response.
    const cacheable = await effectiveCacheableResponsePlugin.cacheWillUpdate(
      {request, response});

    if (cacheable) {
      // If cleanRedirects is set and this is a redirected response, then
      // get a "clean" copy to add to the cache.
      const newResponse = cleanRedirects && response.redirected ?
        await cleanResponseCopy({response}) :
        response.clone();

      // cachingComplete is a promise that may or may not be used to delay the
      // completion of this method, depending on the value of `waitOnCache`.
      cachingComplete = this.getCache().then(async (cache) => {
        let oldResponse;
        const cacheRequest = cacheKey || request;

        // Only bother getting the old response if the new response isn't opaque
        // and there's at least one cacheDidUpdate plugin. Otherwise, we don't
        // need it.
        if (response.type !== 'opaque' &&
          this.plugins.has('cacheDidUpdate')) {
          oldResponse = await this.match({request: cacheRequest});
        }

        // Regardless of whether or not we'll end up invoking
        // cacheDidUpdate, wait until the cache is updated.
        await cache.put(cacheRequest, newResponse);

        if (this.plugins.has('cacheDidUpdate')) {
          for (let plugin of this.plugins.get('cacheDidUpdate')) {
            await plugin.cacheDidUpdate({
              cacheName: this.cacheName,
              oldResponse,
              newResponse,
              // cacheRequest may be a Request with a url property, or a string.
              url: ('url' in cacheRequest) ? cacheRequest.url : cacheRequest,
            });
          }
        }
      });
    } else if (!cacheable && waitOnCache) {
      // If the developer requested to wait on the cache but the response
      // isn't cacheable, throw an error.
      throw ErrorFactory.createError('invalid-response-for-caching');
    }

    // Only conditionally await the caching completion, giving developers the
    // option of returning early for, e.g., read-through-caching scenarios.
    if (waitOnCache && cachingComplete) {
      await cachingComplete;
    }

    return response;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * This a base class which each caching strategy extends.
 *
 * @memberof module:workbox-runtime-caching
 */
class Handler {
  /**
   * Constructor for a new Handler instance.
   *
   * @param {Object} input
   * @param {boolean} [input.waitOnCache] For handlers that write to the cache,
   * `true` means the method should wait for the `cache.put()` call to
   * complete before returning. The default value of `false` means
   * return without waiting. It this value is true and the response
   * can't be cached, an error will be thrown.
   * @param {module:workbox-runtime-caching.RequestWrapper}
   * [input.requestWrapper] An optional `RequestWrapper` that is used to
   * configure the cache name and request plugins. If not provided, a
   * new `RequestWrapper` using the [default cache name](#getDefaultCacheName)
   * will be used.
   */
  constructor({requestWrapper, waitOnCache} = {}) {
    if (requestWrapper) {
      this.requestWrapper = requestWrapper;
    } else {
      this.requestWrapper = new RequestWrapper();
    }

    this.waitOnCache = Boolean(waitOnCache);
  }

  /**
   * An abstract method that each subclass must implement.
   *
   * @abstract
   * @param {Object} input
   * @param {FetchEvent} input.event The event that triggered the service
   *        worker's fetch handler.
   * @param {Object} [input.params] Additional parameters that might be passed
   *        in to the method. If used in conjunction with the
   *        {@link module:workbox-routing.Route|Route} class, then the return
   *        value from the `match` function in the Route constructor
   *        will be passed in as the `params` value.
   * @return {Promise.<Response>} A promise resolving with a response.
   */
  handle({event, params} = {}) {
    throw Error('This abstract method must be implemented in a subclass.');
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * An implementation of a [cache-first](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network)
 * request strategy.
 *
 * The important thing to note with this caching strategy is that once a
 * response is cached, it will not be updated. This is useful for assets
 * that are revisioned since it caches the asset long term and doesn't waste
 * the user's data.
 *
 * @example
 * // Set up a route to match any requests made for URLs that end in .txt.
 * // The requests are handled with a cache-first strategy.
 * const route = new workbox.routing.RegExpRoute({
 *   regExp: /\.txt$/,
 *   handler: new workbox.runtimeCaching.CacheFirst(),
 * });
 *
 * const router = new workbox.routing.Router();
 * router.registerRoute({route});
 *
 * @memberof module:workbox-runtime-caching
 * @extends module:workbox-runtime-caching.Handler
 */
class CacheFirst extends Handler {
  /**
   * The handle method will be called by the
   * {@link module:workbox-routing.Route|Route} class when a route matches a
   * request.
   *
   * @param {Object} input
   * @param {FetchEvent} input.event The event that triggered the service
   *        worker's fetch handler.
   * @return {Promise.<Response>} The response, either from the cache,
   *          or if that isn't available, the request will be made on the
   *          the network and the result will be cached for future use.
   */
  async handle({event} = {}) {
    isInstance({event}, FetchEvent);

    const cachedResponse = await this.requestWrapper.match({
      request: event.request,
    });

    return cachedResponse || await this.requestWrapper.fetchAndCache({
      request: event.request,
      waitOnCache: this.waitOnCache,
    });
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

importScripts('/packages/workbox-runtime-caching/test/utils/setup.js');

describe(`Test of the CacheFirst handler`, function() {
  const CACHE_NAME = location.href;
  const COUNTER_URL = new URL('/__echo/counter', location).href;
  const CROSS_ORIGIN_COUNTER_URL = generateCrossOriginUrl(COUNTER_URL);

  beforeEach(async function() {
    await caches.delete(CACHE_NAME);
  });

  it(`should add the initial response to the cache, and then reuse it without updating the cache`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const cacheFirst = new CacheFirst({requestWrapper, waitOnCache: true});

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const firstHandleResponse = await cacheFirst.handle({event});

    const cache = await caches.open(CACHE_NAME);
    const firstCachedResponse = await cache.match(COUNTER_URL);

    await expectSameResponseBodies(firstHandleResponse, firstCachedResponse);

    const secondHandleResponse = await cacheFirst.handle({event});
    const secondCachedResponse = await cache.match(COUNTER_URL);

    await expectSameResponseBodies(firstCachedResponse, secondHandleResponse);
    await expectSameResponseBodies(firstCachedResponse, secondCachedResponse);
  });

  it(`should not update the cache with an the opaque cross-origin network response by default`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const cacheFirst = new CacheFirst({requestWrapper, waitOnCache: false});

    const event = new FetchEvent('fetch', {
      request: new Request(CROSS_ORIGIN_COUNTER_URL, {mode: 'no-cors'})});
    const handleResponse = await cacheFirst.handle({event});

    expect(handleResponse.type).to.eql('opaque');

    const cache = await caches.open(CACHE_NAME);
    const cachedResponse = await cache.match(CROSS_ORIGIN_COUNTER_URL);

    expect(cachedResponse).to.be.undefined;
  });

  it(`should update the cache with an the opaque cross-origin network response when a cacheWillUpdate plugin returns true`, async function() {
    const cacheWillUpdate = {cacheWillUpdate: () => true};
    const requestWrapper = new RequestWrapper({
      cacheName: CACHE_NAME,
      plugins: [cacheWillUpdate],
    });
    const cacheFirst = new CacheFirst({requestWrapper, waitOnCache: true});

    const event = new FetchEvent('fetch', {
      request: new Request(CROSS_ORIGIN_COUNTER_URL, {mode: 'no-cors'})});
    const handleResponse = await cacheFirst.handle({event});

    expect(handleResponse.type).to.eql('opaque');

    const cache = await caches.open(CACHE_NAME);
    const cachedResponse = await cache.match(CROSS_ORIGIN_COUNTER_URL);

    expect(cachedResponse.type).to.eql('opaque');
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * An implementation of a [cache-only](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only)
 * request strategy.
 *
 * The advantage to using this versus directly calling `caches.match()` is that
 * it will use the cache configuration and trigger the plugins defined in
 * the underlying `RequestWrapper` which accounts for behaviors like cache
 * expiration.
 *
 * @example
 * // Set up a route to match any requests made for URLs that end in .txt.
 * // The requests are handled with a cache-only strategy.
 * const route = new workbox.routing.RegExpRoute({
 *   regExp: /\.txt$/,
 *   handler: new workbox.runtimeCaching.CacheOnly(),
 * });
 *
 * const router = new workbox.routing.Router();
 * router.registerRoute({route});
 *
 * @memberof module:workbox-runtime-caching
 * @extends module:workbox-runtime-caching.Handler
 */
class CacheOnly extends Handler {
  /**
   * The handle method will be called by the
   * {@link module:workbox-routing.Route|Route} class when a route matches a
   * request.
   *
   * @param {Object} input
   * @param {FetchEvent} input.event The event that triggered the service
   *        worker's fetch handler.
   * @return {Promise.<Response>} The response from the cache or null.
   */
  async handle({event} = {}) {
    isInstance({event}, FetchEvent);

    return await this.requestWrapper.match({request: event.request});
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

importScripts('/packages/workbox-runtime-caching/test/utils/setup.js');

describe(`Test of the CacheOnly handler`, function() {
  const CACHE_NAME = location.href;
  const COUNTER_URL = new URL('/__echo/counter', location).href;

  beforeEach(async function() {
    await caches.delete(CACHE_NAME);
  });

  it(`should not return a response when the cache isn't populated`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const cacheOnly = new CacheOnly({requestWrapper});

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await cacheOnly.handle({event});

    expect(handleResponse).not.to.exist;
  });

  it(`should return the cached response when the cache is populated`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const cacheOnly = new CacheOnly({requestWrapper});

    const cachedResponse = new Response('response body');
    const cache = await caches.open(CACHE_NAME);
    await cache.put(COUNTER_URL, cachedResponse.clone());

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await cacheOnly.handle({event});

    await expectSameResponseBodies(cachedResponse, handleResponse);
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * An implementation of a [network first](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache)
 * request strategy.
 *
 * By default, `NetworkFirst` will cache responses with a 200 status code as
 * well as [opaque responses](http://stackoverflow.com/q/39109789)
 * (responses from cross-origin servers which don't support
 * [CORS](https://enable-cors.org/)). You can override this default by passing
 * in a `RequestWrapper` that includes an appropriately-configured
 * `CacheableResponsePlugin`.
 *
 * @example
 * // Set up a route to match any requests made for URLs that end in .txt.
 * // The requests are handled with a network-first strategy.
 * const route = new workbox.routing.RegExpRoute({
 *   regExp: /\.txt$/,
 *   handler: new workbox.runtimeCaching.NetworkFirst(),
 * });
 *
 * const router = new workbox.routing.Router();
 * router.registerRoute({route});
 *
 * @memberof module:workbox-runtime-caching
 * @extends module:workbox-runtime-caching.Handler
 */
class NetworkFirst extends Handler {
  /**
   * Constructor for a new NetworkFirst instance.
   *
   * @param {Object} input
   * @param {number} [input.networkTimeoutSeconds] If set, and a valid network
   *        response isn't returned, then the cached response
   *        will be returned instead. If there is no previously cached response,
   *        then an `null` response will be returned. This option is meant to
   *        combat "[lie-fi](https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi)"
   *        scenarios.
   * @param {RequestWrapper} [input.requestWrapper] An optional `RequestWrapper`
   *        that is used to configure the cache name and request plugins. If
   *        not provided, a new `RequestWrapper` using the
   *        [default cache name](#getDefaultCacheName) will be used.
   */
  constructor(input = {}) {
    super(input);

    this._cacheablePlugin = new CacheableResponsePlugin({statuses: [0, 200]});

    const {networkTimeoutSeconds} = input;
    if (networkTimeoutSeconds) {
      isType({networkTimeoutSeconds}, 'number');
      this.networkTimeoutSeconds = networkTimeoutSeconds;
    }
  }

  /**
   * The handle method will be called by the
   * {@link module:workbox-routing.Route|Route} class when a route matches a
   * request.
   *
   * @param {Object} input
   * @param {FetchEvent} input.event The event that triggered the service
   *        worker's fetch handler.
   * @return {Promise.<Response>} The response from the network, or if that's
   *          not available, a previously cached response.
   */
  async handle({event} = {}) {
    isInstance({event}, FetchEvent);

    const promises = [];
    let timeoutId;

    if (this.networkTimeoutSeconds) {
      promises.push(new Promise((resolve) => {
        timeoutId = setTimeout(() => {
          resolve(this.requestWrapper.match({request: event.request}));
        }, this.networkTimeoutSeconds * 1000);
      }));
    }

    const networkPromise = this.requestWrapper.fetchAndCache({
      request: event.request,
      waitOnCache: this.waitOnCache,
      cacheResponsePlugin: this._cacheablePlugin,
    }).then((response) => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }

      return response ?
        response :
        Promise.reject(ErrorFactory.createError('no-response-received'));
    }).catch(() => this.requestWrapper.match({request: event.request}));

    promises.push(networkPromise);

    return Promise.race(promises);
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * An implementation of a [network-only](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only)
 * request strategy.
 *
 * The advantage to using this versus directly calling `fetch()` is that it will
 * trigger the plugins defined in the underlying `RequestWrapper`.
 *
 *
 * @example
 * // Set up a route to match any requests made for URLs that end in .txt.
 * // The requests are handled with a network-only strategy.
 * const route = new workbox.routing.RegExpRoute({
 *   regExp: /\.txt$/,
 *   handler: new workbox.runtimeCaching.NetworkOnly(),
 * });
 *
 * const router = new workbox.routing.Router();
 * router.registerRoute({route});
 *
 * @memberof module:workbox-runtime-caching
 * @extends module:workbox-runtime-caching.Handler
 */
class NetworkOnly extends Handler {
  /**
   * The handle method will be called by the
   * {@link module:workbox-routing.Route|Route} class when a route matches a
   * request.
   *
   * @param {Object} input
   * @param {FetchEvent} input.event The event that triggered the service
   *        worker's fetch handler.
   * @return {Promise.<Response>} The response from the network.
   */
  async handle({event} = {}) {
    isInstance({event}, FetchEvent);

    return await this.requestWrapper.fetch({request: event.request});
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * An implementation of a [stale-while-revalidate](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate)
 * request strategy.
 *
 * Resources are requested from both the cache and the network in parallel, then
 * responds with the cached version. The cache is replaced with whatever returns
 * from the network. In addition to updating the appropriate caches, it will
 * also trigger any appropriate plugins defined in the underlying
 * `RequestWrapper`.
 *
 * By default, `StaleWhileRevalidate` will cache responses with a 200 status
 * code as well as [opaque responses](http://stackoverflow.com/q/39109789)
 * (responses from cross-origin servers which don't support
 * [CORS](https://enable-cors.org/)). You can override this default by passing
 * in a `RequestWrapper` that includes an appropriately-configured
 * `CacheableResponsePlugin`.
 *
 * @example
 * // Set up a route to match any requests made for URLs that end in .txt.
 * // The requests are handled with a stale-while-revalidate strategy.
 * const route = new workbox.routing.RegExpRoute({
 *   regExp: /\.txt$/,
 *   handler: new workbox.runtimeCaching.StaleWhileRevalidate(),
 * });
 *
 * const router = new workbox.routing.Router();
 * router.registerRoute({route});
 *
 * @memberof module:workbox-runtime-caching
 * @extends module:workbox-runtime-caching.Handler
 */
class StaleWhileRevalidate extends Handler {
  /**
   * Constructor for a new StaleWhileRevalidate instance.
   *
   * @param {Object} input
   * @param {
   * module:workbox-runtime-caching.RequestWrapper} [input.requestWrapper]
   * An optional `RequestWrapper` that is used to
   * configure the cache name and request plugins. If
   * not provided, a new `RequestWrapper` using the
   * [default cache name](#defaultCacheName) will be used.
   */
  constructor(input = {}) {
    super(input);

    this._cacheablePlugin = new CacheableResponsePlugin({statuses: [0, 200]});
  }

  /**
   * The handle method will be called by the
   * {@link module:workbox-routing.Route|Route} class when a route matches a
   * request.
   *
   * @param {Object} input
   * @param {FetchEvent} input.event The event that triggered the service
   *        worker's fetch handler.
   * @return {Promise.<Response>} The response from the cache, if present, or
   *          from the network if not.
   */
  async handle({event} = {}) {
    isInstance({event}, FetchEvent);

    const fetchAndCacheResponse = this.requestWrapper.fetchAndCache({
      request: event.request,
      waitOnCache: this.waitOnCache,
      cacheResponsePlugin: this._cacheablePlugin,
    }).catch(() => Response.error());

    const cachedResponse = await this.requestWrapper.match({
      request: event.request,
    });

    return cachedResponse || await fetchAndCacheResponse;
  }
}

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/**
 * # workbox-runtime-caching
 *
 * A service worker helper library that implements various runtime caching
 * strategies.
 *
 * You can learn more about each caching strategy on
 * {@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/|Jake Archibald's blog post}
 * which covers various ways of handling fetch events with a service worker.
 *
 * These strategies can be used as the
 * [handler parameter in the Route constructor]{@link
 * module:workbox-routing.Route} or as the
 * [handler parameter in workboxSW.router.registerRoute()]{@link
 * module:workbox-sw.Router#registerRoute}.
 *
 * @module workbox-runtime-caching
 */




var namespace = Object.freeze({
	CacheFirst: CacheFirst,
	CacheOnly: CacheOnly,
	Handler: Handler,
	NetworkFirst: NetworkFirst,
	NetworkOnly: NetworkOnly,
	RequestWrapper: RequestWrapper,
	StaleWhileRevalidate: StaleWhileRevalidate,
	getDefaultCacheName: getDefaultCacheName
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

const exportedSymbols = [
  'CacheFirst',
  'CacheOnly',
  'Handler',
  'NetworkFirst',
  'NetworkOnly',
  'RequestWrapper',
  'StaleWhileRevalidate',
  'getDefaultCacheName',
];

describe(`Test Library Surface`, function() {
  exportedSymbols.forEach((exportedSymbol) => {
    it(`should expose ${exportedSymbol} publicly`, function() {
      expect(namespace[exportedSymbol]).to.exist;
    });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

importScripts('/packages/workbox-runtime-caching/test/utils/setup.js');

describe(`Test of the NetworkFirst handler`, function() {
  const CACHE_NAME = location.href;
  const COUNTER_URL = new URL('/__echo/counter', location).href;
  const CROSS_ORIGIN_COUNTER_URL = generateCrossOriginUrl(COUNTER_URL);

  let globalStubs = [];

  beforeEach(async function() {
    await caches.delete(CACHE_NAME);
  });

  afterEach(function() {
    globalStubs.forEach((stub) => stub.restore());
    globalStubs = [];
  });

  it(`should add the network response to the cache`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const networkFirst = new NetworkFirst({requestWrapper, waitOnCache: true});

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await networkFirst.handle({event});

    const cache = await caches.open(CACHE_NAME);
    const cachedResponse = await cache.match(COUNTER_URL);

    await expectSameResponseBodies(cachedResponse, handleResponse);
  });

  it(`should return the cached response and not update the cache when the network request fails`, async function() {
    globalStubs.push(sinon.stub(self, 'fetch').throws('NetworkError'));

    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const networkFirst = new NetworkFirst({requestWrapper, waitOnCache: true});

    const initialCachedResponse = new Response('response body');
    const cache = await caches.open(CACHE_NAME);
    await cache.put(COUNTER_URL, initialCachedResponse.clone());

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await networkFirst.handle({event});

    await expectSameResponseBodies(initialCachedResponse, handleResponse);

    const currentCachedResponse = await cache.match(COUNTER_URL);

    await expectSameResponseBodies(initialCachedResponse, currentCachedResponse);
  });

  it(`should return the cached response if the network request times out`, async function() {
    const networkTimeoutSeconds = 0.1;

    globalStubs.push(sinon.stub(self, 'fetch').callsFake(() => {
      return new Promise((resolve) => {
        setTimeout(() => resolve(new Response('')), (networkTimeoutSeconds * 1000) + 5);
      });
    }));

    const requestWrapper = new RequestWrapper(
      {cacheName: CACHE_NAME});
    const networkFirstWithTimeout = new NetworkFirst(
      {requestWrapper, waitOnCache: true, networkTimeoutSeconds});

    const initialCachedResponse = new Response('response body');
    const cache = await caches.open(CACHE_NAME);
    await cache.put(COUNTER_URL, initialCachedResponse.clone());

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await networkFirstWithTimeout.handle({event});

    await expectSameResponseBodies(initialCachedResponse, handleResponse);
  });

  it(`should throw when NetworkFirst() is called with an invalid networkTimeoutSeconds parameter`, function() {
    expect(() => {
      new NetworkFirst({networkTimeoutSeconds: 'invalid'});
    }).to.throw().with.property('name', 'assertion-failed');
  });

  it(`should return the network response and update the cache when the network request succeeds`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const networkFirst = new NetworkFirst({requestWrapper, waitOnCache: true});

    const initialCachedResponse = new Response('response body');
    const cache = await caches.open(CACHE_NAME);
    await cache.put(COUNTER_URL, initialCachedResponse.clone());

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await networkFirst.handle({event});

    await expectDifferentResponseBodies(initialCachedResponse, handleResponse);

    const currentCachedResponse = await cache.match(COUNTER_URL);

    await expectSameResponseBodies(handleResponse, currentCachedResponse);
  });

  it(`should update the cache with an the opaque cross-origin network response`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const networkFirst = new NetworkFirst({requestWrapper, waitOnCache: true});

    const cache = await caches.open(CACHE_NAME);

    const event = new FetchEvent('fetch',
      {request: new Request(CROSS_ORIGIN_COUNTER_URL, {mode: 'no-cors'})});
    const handleResponse = await networkFirst.handle({event});

    expect(handleResponse.type).to.eql('opaque');

    const cachedResponse = await cache.match(CROSS_ORIGIN_COUNTER_URL);

    expect(cachedResponse.type).to.eql('opaque');
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

importScripts('/packages/workbox-runtime-caching/test/utils/setup.js');

describe(`Test of the NetworkOnly handler`, function() {
  const CACHE_NAME = location.href;
  const COUNTER_URL = new URL('/__echo/counter', location).href;

  let globalStubs = [];

  beforeEach(async function() {
    await caches.delete(CACHE_NAME);
  });

  afterEach(function() {
    globalStubs.forEach((stub) => stub.restore());
    globalStubs = [];
  });

  it(`should return a response without adding anything to the cache when the network request is successful`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const networkOnly = new NetworkOnly({requestWrapper, waitOnCache: true});

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await networkOnly.handle({event});
    expect(handleResponse).to.be.instanceOf(Response);

    const cache = await caches.open(CACHE_NAME);
    const keys = await cache.keys();
    expect(keys).to.be.empty;
  });

  it(`should reject when the network request fails`, function(done) {
    const message = 'expected error';

    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});
    const networkOnly = new NetworkOnly({requestWrapper, waitOnCache: true});

    globalStubs.push(sinon.stub(self, 'fetch').callsFake(() => {
      throw new Error(message);
    }));

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    // This promise should reject, so call done() passing in an error string
    // if it resolves, and done() without an error if it rejects.
    networkOnly.handle({event})
      .then(() => done(new Error('The promise should have rejected.')))
      .catch((error) => {
        if (error.message === message) {
          done();
        } else {
          done(error);
        }
      });
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

importScripts('/packages/workbox-runtime-caching/test/utils/setup.js');

describe(`Test of the RequestWrapper class`, function() {
  const CACHE_NAME = location.href;
  const CACHE_WILL_UPDATE_PLUGIN = {cacheWillUpdate: () => {}};
  const CACHE_WILL_MATCH_PLUGIN = {cachedResponseWillBeUsed: () => {}};
  const CACHED_URL = '/cached';
  const REDIRECTED_URL = '/__test/redirect/301/';

  let globalStubs = [];

  beforeEach(async function() {
    await caches.delete(CACHE_NAME);
  });

  afterEach(function() {
    globalStubs.forEach((stub) => stub.restore());
    globalStubs = [];
  });

  it(`should throw when RequestWrapper() is called with an invalid cacheName parameter`, function() {
    expect(() => {
      new RequestWrapper({cacheName: []});
    }).to.throw().with.property('name', 'assertion-failed');
  });

  it(`should throw when RequestWrapper() is called with an invalid fetchOptions parameter`, function() {
    expect(() => {
      new RequestWrapper({fetchOptions: 'invalid'});
    }).to.throw().with.property('name', 'assertion-failed');
  });

  it(`should throw when RequestWrapper() is called with an invalid matchOptions parameter`, function() {
    expect(() => {
      new RequestWrapper({matchOptions: 'invalid'});
    }).to.throw().with.property('name', 'assertion-failed');
  });

  it(`should throw when RequestWrapper() is called with an invalid plugins parameter`, function() {
    expect(() => {
      new RequestWrapper({plugins: [1]});
    }).to.throw().with.property('name', 'assertion-failed');
  });

  it(`should throw when RequestWrapper() is called with multiple cacheWillUpdate plugins`, function() {
    expect(() => {
      new RequestWrapper({
        plugins: [
          CACHE_WILL_UPDATE_PLUGIN,
          CACHE_WILL_UPDATE_PLUGIN,
        ],
      });
    }).to.throw().with.property('name', 'multiple-cache-will-update-plugins');
  });

  it(`should throw when RequestWrapper() is called with multiple cachedResponseWillBeUsed plugins`, function() {
    expect(() => {
      new RequestWrapper({
        plugins: [
          CACHE_WILL_MATCH_PLUGIN,
          CACHE_WILL_MATCH_PLUGIN,
        ],
      });
    }).to.throw().with.property('name', 'multiple-cached-response-will-be-used-plugins');
  });

  it(`it should throw when RequestWrapper() is called with invalid cacheId`, function() {
    expect(() => {
      new RequestWrapper({cacheId: {}});
    }).to.throw().with.property('name', 'bad-cache-id');
  });

  it(`it should include cacheId in the cacheName`, function() {
    const CACHE_ID = 'CacheIdTest';
    const runtimeCaching = new RequestWrapper({cacheId: CACHE_ID});
    runtimeCaching.cacheName.indexOf(CACHE_ID).should.not.equal(-1);
  });

  it(`it should include cacheId in the cacheName`, function() {
    const CACHE_ID = 'CacheIdTest';
    const CACHE_NAME = 'CacheNameTest';
    const runtimeCaching = new RequestWrapper({
      cacheId: CACHE_ID,
      cacheName: CACHE_NAME,
    });
    runtimeCaching.cacheName.indexOf(CACHE_ID).should.not.equal(-1);
    runtimeCaching.cacheName.indexOf(CACHE_NAME).should.not.equal(-1);
  });

  it(`should return an valid Cache instance when getCache() is called`, async function() {
    const requestWrapper = new RequestWrapper();
    const cache = await requestWrapper.getCache();

    expect(cache).to.be.instanceOf(Cache);
  });

  it(`should find an entry in the correct cache when match() is called`, async function() {
    const requestWrapper = new RequestWrapper({cacheName: CACHE_NAME});

    const cachedResponse = new Response('response body');
    const cache = await caches.open(CACHE_NAME);
    await cache.put(CACHED_URL, cachedResponse.clone());

    const matchResponse = await requestWrapper.match({request: CACHED_URL});

    await expectSameResponseBodies(cachedResponse, matchResponse);
  });

  it(`should correctly respect matchOptions when performing a match()`, async function() {
    const cachedUrlWithSearchParams = `${CACHED_URL}?k=v`;

    const requestWrapperWithoutMatchOptions = new RequestWrapper(
      {cacheName: CACHE_NAME});
    const requestWrapperWithMatchOptions = new RequestWrapper(
      {cacheName: CACHE_NAME, matchOptions: {ignoreSearch: true}});

    const cachedResponse = new Response('response body');
    const cache = await caches.open(CACHE_NAME);
    await cache.put(cachedUrlWithSearchParams, cachedResponse.clone());

    const cacheMissResponse = await requestWrapperWithoutMatchOptions.match(
      {request: CACHED_URL});

    expect(cacheMissResponse).not.to.exist;

    const matchResponse = await requestWrapperWithMatchOptions.match(
      {request: CACHED_URL});

    await expectSameResponseBodies(cachedResponse, matchResponse);
  });

  it(`should fulfill the match() promise with the value returned by a cachedResponseWillBeUsed callback`, async function() {
    const testResponse = new Response('test');
    const cachedResponseWillBeUsedPlugin = {cachedResponseWillBeUsed: () => testResponse};
    const requestWrapper = new RequestWrapper({
      cacheName: CACHE_NAME,
      plugins: [cachedResponseWillBeUsedPlugin],
    });

    const matchResponse = await requestWrapper.match({request: CACHED_URL});

    expect(matchResponse).to.eql(testResponse);
  });

  it(`should return a response from the network when fetch() is called`, async function() {
    const requestWrapper = new RequestWrapper();
    const fetchResponse = await requestWrapper.fetch({request: CACHED_URL});

    expect(fetchResponse).to.be.instanceOf(Response);
  });

  it(`should allow a requestWillFetch to modify the request when fetch() is called`, async function() {
    const fetchStub = sinon.stub(self, 'fetch');
    globalStubs.push(fetchStub);

    const testRequest = new Request('/test');
    const requestWillFetch = {requestWillFetch: () => Promise.resolve(testRequest)};
    const requestWrapper = new RequestWrapper({
      plugins: [requestWillFetch],
    });
    await requestWrapper.fetch({request: CACHED_URL});

    expect(fetchStub.getCall(0).args[0]).to.eql(testRequest);
  });

  it(`should call fetchDidFail when fetch() is called and the network request fails`, function(done) {
    const errorName = 'NetworkError';
    globalStubs.push(sinon.stub(self, 'fetch').throws(errorName));

    const fetchDidFailSpy = sinon.spy();
    const fetchDidFail = {fetchDidFail: fetchDidFailSpy};
    const requestWrapper = new RequestWrapper({
      plugins: [fetchDidFail],
    });
    // This promise should reject, so call done() passing in an error string
    // if it resolves, and done() without an error if it rejects.
    requestWrapper.fetch({request: CACHED_URL})
      .then(() => done(new Error('The promise should have rejected.')))
      .catch((error) => {
        expect(fetchDidFailSpy.firstCall.args[0].request).to.be.instanceOf(Request);
        expect(error.name).to.eql(errorName);
        done();
      });
  });

  it(`should cache the response when fetchAndCache() is called and cacheWillUpdate returns true`, async function() {
    const cacheWillUpdate = {cacheWillUpdate: () => true};
    const requestWrapper = new RequestWrapper({
      plugins: [cacheWillUpdate],
    });

    const cache = await requestWrapper.getCache();

    const cachePutStub = sinon.stub(cache, 'put');
    globalStubs.push(cachePutStub);

    await requestWrapper.fetchAndCache({request: CACHED_URL, waitOnCache: true});

    expect(cachePutStub.firstCall.args[0]).to.eql(CACHED_URL);
    expect(cachePutStub.firstCall.args[1]).to.be.instanceOf(Response);
  });

  it(`should reject without caching the response when fetchAndCache() is called and cacheWillUpdate returns false`, function(done) {
    const cacheWillUpdate = {cacheWillUpdate: () => false};
    const requestWrapper = new RequestWrapper({
      plugins: [cacheWillUpdate],
    });

    requestWrapper.getCache().then((cache) => {
      const cachePutStub = sinon.stub(cache, 'put');
      globalStubs.push(cachePutStub);

      // This promise should reject, so call done() passing in an error string
      // if it resolves, and done() without an error if it rejects.
      requestWrapper.fetchAndCache({request: CACHED_URL, waitOnCache: true})
        .then(() => done(new Error('The promise should have rejected.')))
        .catch((error) => {
          expect(cachePutStub.firstCall).to.be.null;
          expect(error.name).to.eql('invalid-response-for-caching');
          done();
        });
    });
  });

  it(`should cache a non-redirected response when fetchAndCache() is called with cleanRedirects set to true`, async function() {
    const requestWrapper = new RequestWrapper();

    const cache = await requestWrapper.getCache();

    const cachePutStub = sinon.stub(cache, 'put');
    globalStubs.push(cachePutStub);

    await requestWrapper.fetchAndCache({
      request: REDIRECTED_URL,
      waitOnCache: true,
      cleanRedirects: true,
    });

    const [url, response] = cachePutStub.firstCall.args;

    expect(url).to.eql(REDIRECTED_URL);
    expect(response).to.be.instanceOf(Response);
    expect(response.redirected).to.be.false;
  });

  it(`should cache a redirected response when fetchAndCache() is called and cleanRedirects isn't set`, async function() {
    const requestWrapper = new RequestWrapper();

    const cache = await requestWrapper.getCache();

    const cachePutStub = sinon.stub(cache, 'put');
    globalStubs.push(cachePutStub);

    await requestWrapper.fetchAndCache({
      request: REDIRECTED_URL,
      waitOnCache: true,
    });

    const [url, response] = cachePutStub.firstCall.args;

    expect(url).to.eql(REDIRECTED_URL);
    expect(response).to.be.instanceOf(Response);
    expect(response.redirected).to.be.true;
  });
});

/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env mocha, browser */

importScripts('/packages/workbox-runtime-caching/test/utils/setup.js');

describe(`Test of the StaleWhileRevalidate handler`, function() {
  const CACHE_NAME = location.href;
  const COUNTER_URL = new URL('/__echo/counter', location).href;
  const CROSS_ORIGIN_COUNTER_URL = generateCrossOriginUrl(COUNTER_URL);

  let globalStubs = [];

  beforeEach(async function() {
    await caches.delete(CACHE_NAME);
  });

  afterEach(function() {
    globalStubs.forEach((stub) => stub.restore());
    globalStubs = [];
  });

  it(`should add the initial response to the cache`, async function() {
    const requestWrapper = new RequestWrapper(
      {cacheName: CACHE_NAME});
    const staleWhileRevalidate = new StaleWhileRevalidate(
      {requestWrapper, waitOnCache: true});

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await staleWhileRevalidate.handle({event});

    const cache = await caches.open(CACHE_NAME);
    const cachedResponse = await cache.match(COUNTER_URL);

    await expectSameResponseBodies(cachedResponse, handleResponse);
  });

  it(`should return the cached response and not update the cache when the network request fails`, async function() {
    globalStubs.push(sinon.stub(self, 'fetch').throws('NetworkError'));

    const requestWrapper = new RequestWrapper(
      {cacheName: CACHE_NAME});
    const staleWhileRevalidate = new StaleWhileRevalidate(
      {requestWrapper, waitOnCache: true});

    const firstCachedResponse = new Response('response body');
    const cache = await caches.open(CACHE_NAME);
    await cache.put(COUNTER_URL, firstCachedResponse.clone());

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await staleWhileRevalidate.handle({event});

    await expectSameResponseBodies(firstCachedResponse, handleResponse);

    const secondCachedResponse = await cache.match(COUNTER_URL);

    await expectSameResponseBodies(firstCachedResponse, secondCachedResponse);
  });

  it(`should return the cached response and update the cache when the network request succeeds`, async function() {
    const requestWrapper = new RequestWrapper(
      {cacheName: CACHE_NAME});
    const staleWhileRevalidate = new StaleWhileRevalidate(
      {requestWrapper, waitOnCache: true});

    const firstCachedResponse = new Response('response body');
    const cache = await caches.open(CACHE_NAME);
    await cache.put(COUNTER_URL, firstCachedResponse.clone());

    const wrapperCache = await requestWrapper.getCache();
    const cachePutPromise = new Promise((resolve) => {
      const cachePutStub = sinon.stub(wrapperCache, 'put').callsFake((request, response) => {
        resolve(response);
      });
      globalStubs.push(cachePutStub);
    });

    const event = new FetchEvent('fetch', {request: new Request(COUNTER_URL)});
    const handleResponse = await staleWhileRevalidate.handle({event});

    await expectSameResponseBodies(firstCachedResponse, handleResponse);

    const secondCachedResponse = await cachePutPromise;

    await expectDifferentResponseBodies(firstCachedResponse, secondCachedResponse);
  });

  it(`should update the cache with an the opaque cross-origin network response`, async function() {
    const requestWrapper = new RequestWrapper(
      {cacheName: CACHE_NAME});
    const staleWhileRevalidate = new StaleWhileRevalidate(
      {requestWrapper, waitOnCache: true});

    const wrapperCache = await requestWrapper.getCache();
    const cachePutPromise = new Promise((resolve) => {
      const cachePutStub = sinon.stub(wrapperCache, 'put').callsFake((request, response) => {
        resolve(response);
      });
      globalStubs.push(cachePutStub);
    });

    const event = new FetchEvent('fetch',
      {request: new Request(CROSS_ORIGIN_COUNTER_URL, {mode: 'no-cors'})});
    const handleResponse = await staleWhileRevalidate.handle({event});

    expect(handleResponse.type).to.eql('opaque');

    const cachedResponse = await cachePutPromise;

    expect(cachedResponse.type).to.eql('opaque');
  });
});
//# sourceMappingURL=sw-bundle.js.map
